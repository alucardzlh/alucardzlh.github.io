{"content":"{\"__ud_title\":\"Dynamic programming 动态规划\",\"__ud_tags\":[\"算法\"],\"__ud_update_time\":1752302985182,\"__ud_create_time\":1752209662721,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1,\"id\":\"Dynamic-programming-动态规划\"},\"content\":[{\"type\":\"text\",\"text\":\"Dynamic programming 动态规划\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"基础\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1,\"type\":null},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"动态规划三大特性 动态转移方程，重叠子问题，最优子结构\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"核心计算框架 =  base case + 穷举状态 + 进行状态转移；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"递归时间复杂度 = 递归调用的次数 X 递归函数本身的复杂度；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"递归次数就是递归树上的节点数，高度为N的二叉树，2^n\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"暴力穷举 O1 *O2^n\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"public int fib(int n){\\n// base case\\nif(n ==0||n== 1)return n;\\n// 递推关系\\nreturn fib(n-1)+ fib(n-2);\\n}\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"合理剪枝，备忘录缓存优化，自顶向下， O1 * On  空间复杂度换时间，树形变链型；\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"/* 备忘录递归法 */\\n\\n    public int fib(int N){\\n\\t\\t// 备忘录全初始化为 0\\n\\t\\tint[]memo =new int[N + 1];\\n\\t\\t// 进行带备忘录的递归\\n        // 用于存储计算过了的结果，合理剪枝\\n\\t\\treturn helper(memo,N);\\n    }\\n\\tprivate int helper(int[]memo,int n){\\n\\t// base case\\n\\tif(n==0||n==1)return n;\\n\\t//已经计算过，不用再计算了\\n\\tif(memo[n]!=0)return memo[n];\\n\\tmemo[n]= helper(memo,n-1)+helper(memo,n-2);\\n\\treturn memo[n];\\n\\t}\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"自底向上，优化后空间压缩\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"/*自底向上，表格法*/\\n  public int fib(int N){\\n    if(N == 0)return 0;\\n    int[]dp = new int[N + 1];\\n    // base case\\n    dp[0]=0; dp[1]卡1;\\n    // 状态转移\\n    for(int i=2;i <= N; i++)\\n      dp[i]=dp[i-1]+dp[i -2];\\n      return dp[N];\\n    }\\n\\n/*优化后*/\\n  public int fib(int n){\\n    // base case\\n    if(n ==0||n == 1)\\n    return n;\\n    // 递推关系\\n    // 把数组压缩成计算时所需的前两位\\n    // 压缩节约空间\\n    int prev=0，curr=1;\\n      for(inti=2;i<= n; i++){\\n        int sum = prev + curr;\\n        prev = curr;\\n        curr = sum;\\n      }\\n    return curr;\\n  }\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"hardBreak\"}]}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"零钱兑换\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"给定不同面额的硬币 coins 和一个总金额 amount 。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"你可以认为每种硬币的数量是无限的。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"示例： coins = [1,2,5], amount=11\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"输出：3\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"解释：11 = 5 + 5 + 1 \"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1,\"type\":null},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"状态 = 可变参数，选择 = 导致你状态变化的，函数定义\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"状态：目标金额 amount， 选择：coins 数组中李处的所有硬币面额；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"函数定义：凑出总金额 amount，至少需要 coinChange(coins,amount)枚硬币；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"base case： amount == 0 时， 需要 0枚 硬币； amount<0 时， 不可能凑出；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"核心思路：把求11拆解成 求10(11-1)、9(11-2)、6(11-5)，遍历coins；\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"java\"},\"content\":[{\"type\":\"text\",\"text\":\"/*暴力法*/\\npublic int coinChange(int[]coins,int amount){\\n  // base case\\n  if(amount ==0)return 0;\\n  if(amount<0)return -1;\\n\\n  int res = Integer.MAX VALUE;\\n    for(int coin :coins){\\n    // 计算子问题的结果\\n    int subProblem=coinChange(coins，amount-coin);\\n    // 子问题无解则跳过\\n    if(subProblem ==-1)continue;\\n\\n    //如果子问题合法，表示获得一次子解+1等于当前解  \\n    //在子问题中选择最优解，然后加一\\n    res = Math.min(res,subProblem+1);\\n    }\\n  //如果没有获取到赋值，\\n  return res ==Integer.MAX VALUE ?-1 :res;\\n}\\n\\n/*备忘录优化后*/\\nint[] memo;\\npublic int coinChange(int[]coins,int amount){\\n    memo = new int[amount + 1];\\n    //初始化,赋无意义特殊值,标识是否被计算过\\n    Arrays.fill(memo,-666);\\n    \\n    return dp(coins, amount);\\n\\n}\\nprivate int dp(int[] coins,int amount){\\n    if(amount ==0)return 0;\\n    if(amount<0)return -1;\\n    //查询备忘录，防止重复计算\\n    if(memo[amount] !=-666) return memo[amount];\\n    \\n    int res = Integer.MAX VALUE;\\n\\n    for(int coin : coins){\\n    // 计算子问题的结果\\n    int subProblem=coinChange(coins，amount-coin);\\n    // 子问题无解则跳过\\n    if(subProblem ==-1)continue;\\n    //如果子问题合法，表示获得一次子解+1等于当前解  \\n    //在子问题中选择最优解，然后加一\\n    res =Math.min(res,subProblem+1);\\n    }\\n    //把计算结果存入备忘录\\n    memo[amount]= (res == Integer.MAX_VALUE) ? -1 : res;\\n    return memo[amount];\\n}\\n\\n\\n/*自底向上*/\\npublic int coinChange(int[lcoins,int amount){\\n    //这里+1是为了模拟非法值，amount最优解最多就等于amount/1\\n    //所以+1就非法了，+10，+100道理一样\\n    int[]dp =new int[amount + 1];\\n    // dp 数组全都初始化为特殊值 amount+1Arrays.fill(dp,amount+1);\\n    // dp 数组的定义:凑出总金额 amount，至少需要 dp[amount]枚硬币\\n    // base case\\n    dp[0]= 0;\\n    //外层 for 循环在遍历所有状态的所有取值\\n    for(int i=0;i<dp.length; i++){\\n        //内层 for 循环在求所有选择的最小值\\n        for(int coin:coins){\\n          // 子问题无解，跳过\\n          if(i-coin <0)continue;\\n          // 状态转移\\n          dp[i]= Math.min(dp[i],1 + dp[i -coin]);\\n        }\\n    }\\n    // 看看金额 amount 能不能凑出来\\n    return(dp[amount]== amount+1)?-1 :dp[amount];\\n}\"}]},{\"type\":\"paragraph\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"大部分计算机问题，都是先做暴力穷举，尽可能列出所有解；\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"然后在暴力穷举的前提下取优化，去剪枝，达到更聪明的穷举，缩减时间、空间复杂度；\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":null},\"content\":[{\"type\":\"text\",\"text\":\"背包问题\"}]}]}","title":"Dynamic programming 动态规划","tags":["算法"],"updateTime":1752302985182,"createTime":1752209662721,"draft":false,"intro":"","html":"<h1 level=\"1\" id=\"Dynamic-programming-动态规划\">Dynamic programming 动态规划</h1><p></p><h2 level=\"2\" id=\"基础\">基础</h2><ol><li><p>动态规划三大特性 动态转移方程，重叠子问题，最优子结构</p></li><li><p>核心计算框架 =  base case + 穷举状态 + 进行状态转移；</p></li><li><p>递归时间复杂度 = 递归调用的次数 X 递归函数本身的复杂度；</p></li><li><p>递归次数就是递归树上的节点数，高度为N的二叉树，2^n</p></li><li><p>暴力穷举 O1 *O2^n</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fib</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span> n)</span>{\n<span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(n ==<span class=\"hljs-number\" class=\"hljs-number\">0</span>||n== <span class=\"hljs-number\" class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> n;\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 递推关系</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> fib(n-<span class=\"hljs-number\" class=\"hljs-number\">1</span>)+ fib(n-<span class=\"hljs-number\" class=\"hljs-number\">2</span>);\n}</code></pre></div></div></li><li><p>合理剪枝，备忘录缓存优化，自顶向下， O1 * On  空间复杂度换时间，树形变链型；</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\"><span class=\"hljs-comment\" class=\"hljs-comment\">/* 备忘录递归法 */</span>\n\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fib</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span> N)</span>{\n\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 备忘录全初始化为 0</span>\n\t\t<span class=\"hljs-type\" class=\"hljs-type\">int</span>[]memo =<span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">int</span>[N + <span class=\"hljs-number\" class=\"hljs-number\">1</span>];\n\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 进行带备忘录的递归</span>\n        <span class=\"hljs-comment\" class=\"hljs-comment\">// 用于存储计算过了的结果，合理剪枝</span>\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> helper(memo,N);\n    }\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">private</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">helper</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[]memo,<span class=\"hljs-type\" class=\"hljs-type\">int</span> n)</span>{\n\t<span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\" class=\"hljs-number\">0</span>||n==<span class=\"hljs-number\" class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> n;\n\t<span class=\"hljs-comment\" class=\"hljs-comment\">//已经计算过，不用再计算了</span>\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(memo[n]!=<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> memo[n];\n\tmemo[n]= helper(memo,n-<span class=\"hljs-number\" class=\"hljs-number\">1</span>)+helper(memo,n-<span class=\"hljs-number\" class=\"hljs-number\">2</span>);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> memo[n];\n\t}</code></pre></div></div></li><li><p>自底向上，优化后空间压缩</p><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\"><span class=\"hljs-comment\" class=\"hljs-comment\">/*自底向上，表格法*/</span>\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fib</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span> N)</span>{\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(N == <span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-number\" class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\" class=\"hljs-type\">int</span>[]dp = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">int</span>[N + <span class=\"hljs-number\" class=\"hljs-number\">1</span>];\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n    dp[<span class=\"hljs-number\" class=\"hljs-number\">0</span>]=<span class=\"hljs-number\" class=\"hljs-number\">0</span>; dp[<span class=\"hljs-number\" class=\"hljs-number\">1</span>]卡<span class=\"hljs-number\" class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 状态转移</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> i=<span class=\"hljs-number\" class=\"hljs-number\">2</span>;i &lt;= N; i++)\n      dp[i]=dp[i-<span class=\"hljs-number\" class=\"hljs-number\">1</span>]+dp[i -<span class=\"hljs-number\" class=\"hljs-number\">2</span>];\n      <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> dp[N];\n    }\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">/*优化后*/</span>\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fib</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span> n)</span>{\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(n ==<span class=\"hljs-number\" class=\"hljs-number\">0</span>||n == <span class=\"hljs-number\" class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> n;\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 递推关系</span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 把数组压缩成计算时所需的前两位</span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 压缩节约空间</span>\n    <span class=\"hljs-type\" class=\"hljs-type\">int</span> prev=<span class=\"hljs-number\" class=\"hljs-number\">0</span>，curr=<span class=\"hljs-number\" class=\"hljs-number\">1</span>;\n      <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(inti=<span class=\"hljs-number\" class=\"hljs-number\">2</span>;i&lt;= n; i++){\n        <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-variable\" class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> prev + curr;\n        prev = curr;\n        curr = sum;\n      }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> curr;\n  }</code></pre></div></div></li><li><p><br></p></li></ol><h2 level=\"2\" id=\"零钱兑换\">零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount 。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例： coins = [1,2,5], amount=11</p><p>输出：3</p><p>解释：11 = 5 + 5 + 1 </p><ol><li><p>状态 = 可变参数，选择 = 导致你状态变化的，函数定义</p></li><li><p>状态：目标金额 amount， 选择：coins 数组中李处的所有硬币面额；</p></li><li><p>函数定义：凑出总金额 amount，至少需要 coinChange(coins,amount)枚硬币；</p></li><li><p>base case： amount == 0 时， 需要 0枚 硬币； amount&lt;0 时， 不可能凑出；</p></li><li><p>核心思路：把求11拆解成 求10(11-1)、9(11-2)、6(11-5)，遍历coins；</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">java</div><div class=\"wrapper\"><pre><code class=\"language-java\"><span class=\"hljs-comment\" class=\"hljs-comment\">/*暴力法*/</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">coinChange</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[]coins,<span class=\"hljs-type\" class=\"hljs-type\">int</span> amount)</span>{\n  <span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(amount ==<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-number\" class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(amount&lt;<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\" class=\"hljs-number\">1</span>;\n\n  <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-variable\" class=\"hljs-variable\">res</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> Integer.MAX VALUE;\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> coin :coins){\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 计算子问题的结果</span>\n    <span class=\"hljs-type\" class=\"hljs-type\">int</span> subProblem=coinChange(coins，amount-coin);\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 子问题无解则跳过</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(subProblem ==-<span class=\"hljs-number\" class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">continue</span>;\n\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//如果子问题合法，表示获得一次子解+1等于当前解  </span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//在子问题中选择最优解，然后加一</span>\n    res = Math.min(res,subProblem+<span class=\"hljs-number\" class=\"hljs-number\">1</span>);\n    }\n  <span class=\"hljs-comment\" class=\"hljs-comment\">//如果没有获取到赋值，</span>\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> res ==Integer.MAX VALUE ?-<span class=\"hljs-number\" class=\"hljs-number\">1</span> :res;\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">/*备忘录优化后*/</span>\n<span class=\"hljs-type\" class=\"hljs-type\">int</span>[] memo;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">coinChange</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[]coins,<span class=\"hljs-type\" class=\"hljs-type\">int</span> amount)</span>{\n    memo = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">int</span>[amount + <span class=\"hljs-number\" class=\"hljs-number\">1</span>];\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//初始化,赋无意义特殊值,标识是否被计算过</span>\n    Arrays.fill(memo,-<span class=\"hljs-number\" class=\"hljs-number\">666</span>);\n    \n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> dp(coins, amount);\n\n}\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">private</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">dp</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[] coins,<span class=\"hljs-type\" class=\"hljs-type\">int</span> amount)</span>{\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(amount ==<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-number\" class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(amount&lt;<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\" class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//查询备忘录，防止重复计算</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(memo[amount] !=-<span class=\"hljs-number\" class=\"hljs-number\">666</span>) <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> memo[amount];\n    \n    <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-variable\" class=\"hljs-variable\">res</span> <span class=\"hljs-operator\" class=\"hljs-operator\">=</span> Integer.MAX VALUE;\n\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> coin : coins){\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 计算子问题的结果</span>\n    <span class=\"hljs-type\" class=\"hljs-type\">int</span> subProblem=coinChange(coins，amount-coin);\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 子问题无解则跳过</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(subProblem ==-<span class=\"hljs-number\" class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">continue</span>;\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//如果子问题合法，表示获得一次子解+1等于当前解  </span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//在子问题中选择最优解，然后加一</span>\n    res =Math.min(res,subProblem+<span class=\"hljs-number\" class=\"hljs-number\">1</span>);\n    }\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//把计算结果存入备忘录</span>\n    memo[amount]= (res == Integer.MAX_VALUE) ? -<span class=\"hljs-number\" class=\"hljs-number\">1</span> : res;\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> memo[amount];\n}\n\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">/*自底向上*/</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">public</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">coinChange</span><span class=\"hljs-params\" class=\"hljs-params\">(<span class=\"hljs-type\" class=\"hljs-type\">int</span>[lcoins,<span class=\"hljs-type\" class=\"hljs-type\">int</span> amount)</span>{\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//这里+1是为了模拟非法值，amount最优解最多就等于amount/1</span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//所以+1就非法了，+10，+100道理一样</span>\n    <span class=\"hljs-type\" class=\"hljs-type\">int</span>[]dp =<span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">int</span>[amount + <span class=\"hljs-number\" class=\"hljs-number\">1</span>];\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// dp 数组全都初始化为特殊值 amount+1Arrays.fill(dp,amount+1);</span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// dp 数组的定义:凑出总金额 amount，至少需要 dp[amount]枚硬币</span>\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// base case</span>\n    dp[<span class=\"hljs-number\" class=\"hljs-number\">0</span>]= <span class=\"hljs-number\" class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\" class=\"hljs-comment\">//外层 for 循环在遍历所有状态的所有取值</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> i=<span class=\"hljs-number\" class=\"hljs-number\">0</span>;i&lt;dp.length; i++){\n        <span class=\"hljs-comment\" class=\"hljs-comment\">//内层 for 循环在求所有选择的最小值</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\" class=\"hljs-type\">int</span> coin:coins){\n          <span class=\"hljs-comment\" class=\"hljs-comment\">// 子问题无解，跳过</span>\n          <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(i-coin &lt;<span class=\"hljs-number\" class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\" class=\"hljs-keyword\">continue</span>;\n          <span class=\"hljs-comment\" class=\"hljs-comment\">// 状态转移</span>\n          dp[i]= Math.min(dp[i],<span class=\"hljs-number\" class=\"hljs-number\">1</span> + dp[i -coin]);\n        }\n    }\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 看看金额 amount 能不能凑出来</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span>(dp[amount]== amount+<span class=\"hljs-number\" class=\"hljs-number\">1</span>)?-<span class=\"hljs-number\" class=\"hljs-number\">1</span> :dp[amount];\n}</code></pre></div></div><p></p><p>大部分计算机问题，都是先做暴力穷举，尽可能列出所有解；</p><p>然后在暴力穷举的前提下取优化，去剪枝，达到更聪明的穷举，缩减时间、空间复杂度；</p><p></p><h2 level=\"2\" id=\"背包问题\">背包问题</h2><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"Dynamic-programming-动态规划","path":"/posts/Dynamic-programming-动态规划.json"}