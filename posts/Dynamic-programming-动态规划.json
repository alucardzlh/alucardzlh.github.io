{"__ud_title":"Dynamic programming 动态规划","__ud_tags":["算法"],"__ud_update_time":1752302985182,"__ud_create_time":1752209662721,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1,"id":"Dynamic-programming-动态规划"},"content":[{"type":"text","text":"Dynamic programming 动态规划"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"基础"}]},{"type":"orderedList","attrs":{"start":1,"type":null},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"动态规划三大特性 动态转移方程，重叠子问题，最优子结构"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"核心计算框架 =  base case + 穷举状态 + 进行状态转移；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"递归时间复杂度 = 递归调用的次数 X 递归函数本身的复杂度；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"递归次数就是递归树上的节点数，高度为N的二叉树，2^n"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"暴力穷举 O1 *O2^n"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"public int fib(int n){\n// base case\nif(n ==0||n== 1)return n;\n// 递推关系\nreturn fib(n-1)+ fib(n-2);\n}"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"合理剪枝，备忘录缓存优化，自顶向下， O1 * On  空间复杂度换时间，树形变链型；"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"/* 备忘录递归法 */\n\n    public int fib(int N){\n\t\t// 备忘录全初始化为 0\n\t\tint[]memo =new int[N + 1];\n\t\t// 进行带备忘录的递归\n        // 用于存储计算过了的结果，合理剪枝\n\t\treturn helper(memo,N);\n    }\n\tprivate int helper(int[]memo,int n){\n\t// base case\n\tif(n==0||n==1)return n;\n\t//已经计算过，不用再计算了\n\tif(memo[n]!=0)return memo[n];\n\tmemo[n]= helper(memo,n-1)+helper(memo,n-2);\n\treturn memo[n];\n\t}"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"自底向上，优化后空间压缩"}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"/*自底向上，表格法*/\n  public int fib(int N){\n    if(N == 0)return 0;\n    int[]dp = new int[N + 1];\n    // base case\n    dp[0]=0; dp[1]卡1;\n    // 状态转移\n    for(int i=2;i <= N; i++)\n      dp[i]=dp[i-1]+dp[i -2];\n      return dp[N];\n    }\n\n/*优化后*/\n  public int fib(int n){\n    // base case\n    if(n ==0||n == 1)\n    return n;\n    // 递推关系\n    // 把数组压缩成计算时所需的前两位\n    // 压缩节约空间\n    int prev=0，curr=1;\n      for(inti=2;i<= n; i++){\n        int sum = prev + curr;\n        prev = curr;\n        curr = sum;\n      }\n    return curr;\n  }"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"hardBreak"}]}]}]},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"零钱兑换"}]},{"type":"paragraph","content":[{"type":"text","text":"给定不同面额的硬币 coins 和一个总金额 amount 。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。"}]},{"type":"paragraph","content":[{"type":"text","text":"你可以认为每种硬币的数量是无限的。"}]},{"type":"paragraph","content":[{"type":"text","text":"示例： coins = [1,2,5], amount=11"}]},{"type":"paragraph","content":[{"type":"text","text":"输出：3"}]},{"type":"paragraph","content":[{"type":"text","text":"解释：11 = 5 + 5 + 1 "}]},{"type":"orderedList","attrs":{"start":1,"type":null},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"状态 = 可变参数，选择 = 导致你状态变化的，函数定义"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"状态：目标金额 amount， 选择：coins 数组中李处的所有硬币面额；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"函数定义：凑出总金额 amount，至少需要 coinChange(coins,amount)枚硬币；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"base case： amount == 0 时， 需要 0枚 硬币； amount<0 时， 不可能凑出；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"核心思路：把求11拆解成 求10(11-1)、9(11-2)、6(11-5)，遍历coins；"}]}]}]},{"type":"codeBlock","attrs":{"language":"java"},"content":[{"type":"text","text":"/*暴力法*/\npublic int coinChange(int[]coins,int amount){\n  // base case\n  if(amount ==0)return 0;\n  if(amount<0)return -1;\n\n  int res = Integer.MAX VALUE;\n    for(int coin :coins){\n    // 计算子问题的结果\n    int subProblem=coinChange(coins，amount-coin);\n    // 子问题无解则跳过\n    if(subProblem ==-1)continue;\n\n    //如果子问题合法，表示获得一次子解+1等于当前解  \n    //在子问题中选择最优解，然后加一\n    res = Math.min(res,subProblem+1);\n    }\n  //如果没有获取到赋值，\n  return res ==Integer.MAX VALUE ?-1 :res;\n}\n\n/*备忘录优化后*/\nint[] memo;\npublic int coinChange(int[]coins,int amount){\n    memo = new int[amount + 1];\n    //初始化,赋无意义特殊值,标识是否被计算过\n    Arrays.fill(memo,-666);\n    \n    return dp(coins, amount);\n\n}\nprivate int dp(int[] coins,int amount){\n    if(amount ==0)return 0;\n    if(amount<0)return -1;\n    //查询备忘录，防止重复计算\n    if(memo[amount] !=-666) return memo[amount];\n    \n    int res = Integer.MAX VALUE;\n\n    for(int coin : coins){\n    // 计算子问题的结果\n    int subProblem=coinChange(coins，amount-coin);\n    // 子问题无解则跳过\n    if(subProblem ==-1)continue;\n    //如果子问题合法，表示获得一次子解+1等于当前解  \n    //在子问题中选择最优解，然后加一\n    res =Math.min(res,subProblem+1);\n    }\n    //把计算结果存入备忘录\n    memo[amount]= (res == Integer.MAX_VALUE) ? -1 : res;\n    return memo[amount];\n}\n\n\n/*自底向上*/\npublic int coinChange(int[lcoins,int amount){\n    //这里+1是为了模拟非法值，amount最优解最多就等于amount/1\n    //所以+1就非法了，+10，+100道理一样\n    int[]dp =new int[amount + 1];\n    // dp 数组全都初始化为特殊值 amount+1Arrays.fill(dp,amount+1);\n    // dp 数组的定义:凑出总金额 amount，至少需要 dp[amount]枚硬币\n    // base case\n    dp[0]= 0;\n    //外层 for 循环在遍历所有状态的所有取值\n    for(int i=0;i<dp.length; i++){\n        //内层 for 循环在求所有选择的最小值\n        for(int coin:coins){\n          // 子问题无解，跳过\n          if(i-coin <0)continue;\n          // 状态转移\n          dp[i]= Math.min(dp[i],1 + dp[i -coin]);\n        }\n    }\n    // 看看金额 amount 能不能凑出来\n    return(dp[amount]== amount+1)?-1 :dp[amount];\n}"}]},{"type":"paragraph"},{"type":"paragraph","content":[{"type":"text","text":"大部分计算机问题，都是先做暴力穷举，尽可能列出所有解；"}]},{"type":"paragraph","content":[{"type":"text","text":"然后在暴力穷举的前提下取优化，去剪枝，达到更聪明的穷举，缩减时间、空间复杂度；"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":null},"content":[{"type":"text","text":"背包问题"}]}]}